<html>
<head>
	<style>
		.myVideo {
  			position: absolute;
			top: 0;
			left: 0;
			/*
			min-width: 100%; 
			min-height: 100%;
			*/
		}
	</style>
</head>
<body>

<video class="myVideo" id="video" width="640" height="480" ></video>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ismobilejs@1/dist/isMobile.min.js"></script>
<script async src="js/artoolkit/artoolkit.debug.js">
	// - include debug build
				</script>
				<script src="js/artoolkit/artoolkit.api.js">
				// - include JS API
				</script>

<script id="vert" type="glsl-vertex">
precision highp float;
precision lowp int;

uniform mat4 cameraMatrix;
uniform mat4 transformationMatrix;

varying vec2 vUv;

void main(void)
{
	vUv = uv;
	gl_Position = cameraMatrix * transformationMatrix * vec4(position, 1.0);
}
</script>

<script id="frag" type="glsl-fragment">
precision highp float;
precision lowp int;

varying vec2 vUv;

void main(void)
{
	gl_FragColor = vec4(vUv, 1.0, 1.0);
}
</script>

<script>
var video = document.getElementById('video');


if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    var hint = {};
    if (isMobile.apple.phone || isMobile.android.phone) {
        hint = {
            facingMode: {"ideal": "environment"},
            audio: false,
            video: {
                width: {min: video.width, max: video.width},
                height: {min: video.height, max: video.height},
            },
        };
    }

    navigator.mediaDevices.getUserMedia({video: hint}).then(function (stream) {
        video.srcObject = stream;
        video.play();
    });
}

var cMat = new THREE.Matrix4();
var tMat = new THREE.Matrix4();

var USE_SHADER = false;



var shaderMaterial = new THREE.ShaderMaterial({
	uniforms: {
		cameraMatrix: {type: 'm4', value: cMat },
		transformationMatrix: {type: 'm4', value: tMat }
	},
	vertexShader: vert.text,
	fragmentShader: frag.text
});


var renderer = new THREE.WebGLRenderer({
	antialias	: true,
	alpha: true
});
var scene = new THREE.Scene();

renderer.setSize(video.width, video.height);
renderer.domElement.style.position = 'absolute'
renderer.domElement.style.left = 0;
renderer.domElement.style.top = 0;

document.body.appendChild(renderer.domElement);

// Create a camera and a marker root object for your Three.js scene.
var camera = new THREE.Camera();
scene.add(camera);

var light = new THREE.PointLight(0xffffff);
light.position.set(400, 500, 100);
scene.add(light);
var light = new THREE.PointLight(0xffffff);
light.position.set(-400, -500, -100);
scene.add(light);

var markerRoot = new THREE.Object3D();

markerRoot.wasVisible = false;
markerRoot.markerMatrix = new Float64Array(12);
markerRoot.matrixAutoUpdate = false;
camera.matrixAutoUpdate = false;

// Add the marker models and suchlike into your marker root object.

var cube = new THREE.Mesh(
	new THREE.BoxGeometry(1,1,1),
	USE_SHADER ?
		shaderMaterial :
		new THREE.MeshLambertMaterial({ color: 0xffffff, wireframe: false })
);
markerRoot.add(cube);

// Add the marker root to your scene.
scene.add(markerRoot);
var arController = null;

// On every frame do the following:
function tick() {
	requestAnimationFrame(tick);

	if (!arController) {
		return;
	}

	arController.process(video);
	
	var markerNum = arController.getMarkerNum();
	if (markerNum > 0) {

		if (markerRoot.visible) {
			arController.getTransMatSquareCont(0, 1, markerRoot.markerMatrix, markerRoot.markerMatrix);
		} else {
			arController.getTransMatSquare(0 /* Marker index */, 1 /* Marker width */, markerRoot.markerMatrix);
		}
		markerRoot.visible = true;
		if (USE_SHADER) {
            arController.arglCameraViewRHf(arController.transMatToGLMat(markerRoot.markerMatrix), shaderMaterial.uniforms.transformationMatrix.value.elements);
		} else {
            arController.arglCameraViewRHf(arController.transMatToGLMat(markerRoot.markerMatrix), markerRoot.matrix.elements);
        }

	} else {
		markerRoot.visible = false;
	}


	// Render the scene.
	renderer.autoClear = false;
	renderer.clear();
	renderer.render(scene, camera);
}

tick();

var interval = setTimeout(function() {
	var cameraParam = new ARCameraParam();
	cameraParam.onload = async function() {

		arController = new ARController(video.width, video.height, cameraParam);
		//arController.debugSetup();

		arController.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);
		arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_3x3)

		arController.addEventListener('markerNum', function (ev) {
			console.log('got markers', markerNum);
		});

		arController.addEventListener('getMarker', function (ev) {
			console.log('found marker?', ev);
		});
			
		var camera_mat = arController.getCameraMatrix();

		if (USE_SHADER) {
			shaderMaterial.uniforms.cameraMatrix.value.fromArray(camera_mat);
		} else {
			camera.projectionMatrix.fromArray(camera_mat);
		}

	};
	cameraParam.load('assets/camera_para.dat');
}, 200);

	// handle resize event
	window.addEventListener('resize', function(){
		
		
	});
	

</script>

</body>
</html>
